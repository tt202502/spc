<!DOCTYPE html>
<html>
    <head>
        <title>专业剑 : ms-customer-authorization</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body class="theme-default aui-theme-default">
        <div id="page">
            <div id="main" class="aui-page-panel">
                <div id="main-header">
                    <div id="breadcrumb-section">
                        <ol id="breadcrumbs">
                            <li class="first">
                                <span><a href="index.html">专业剑</a></span>
                            </li>
                                                    <li>
                                <span><a href="Base-Services_6389781.html">Base Services</a></span>
                            </li>
                                                </ol>
                    </div>
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            专业剑 : ms-customer-authorization
                        </span>
                    </h1>
                </div>

                <div id="content" class="view">
                    <div class="page-metadata">
                        
        
    
        
    
        
        
            Created by <span class='author'> admin</span>, last modified on 四月 27, 2025
                        </div>
                    <div id="main-content" class="wiki-content group">
                    <p><style type='text/css'>/*<![CDATA[*/
div.rbtoc1749908443977 {padding: 0px;}
div.rbtoc1749908443977 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1749908443977 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style><div class='toc-macro rbtoc1749908443977'>
<ul class='toc-indentation'>
<li><a href='#ms-customer-authorization-服务描述'>服务描述</a></li>
<li><a href='#ms-customer-authorization-主要API'>主要API</a></li>
<li><a href='#ms-customer-authorization-'></a>
<ul class='toc-indentation'>
<li><a href='#ms-customer-authorization-分析'>分析</a></li>
<li><a href='#ms-customer-authorization-API/tac/request'>API /tac/request</a>
<ul class='toc-indentation'>
<li><a href='#ms-customer-authorization-1.TwoStepElevationController'>1. TwoStepElevationController</a></li>
<li><a href='#ms-customer-authorization-2.TwoStepElevationServiceImpl'>2. TwoStepElevationServiceImpl</a>
<ul class='toc-indentation'>
<li><a href='#ms-customer-authorization-服务层，主要方法tacRequest()'>服务层，主要方法tacRequest()</a></li>
</ul>
</li>
<li><a href='#ms-customer-authorization-3.TACRequestServiceImpl'>3. TACRequestServiceImpl</a>
<ul class='toc-indentation'>
<li><a href='#ms-customer-authorization-预处理：'>预处理：</a></li>
<li><a href='#ms-customer-authorization-Step1：getUserProfile获取用户和token信息'>Step1：getUserProfile 获取用户和token信息</a></li>
<li><a href='#ms-customer-authorization-Step2：prepareRequestDetail获取交易类型的配置信息，同步最新数据'>Step2：prepareRequestDetail 获取交易类型的配置信息，同步最新数据</a></li>
<li><a href='#ms-customer-authorization-Step3：decideAuthorizationType判断（用户可选的）授权类型'>Step3：decideAuthorizationType 判断（用户可选的）授权类型</a></li>
<li><a href='#ms-customer-authorization-Step4：updateAndTrigger请求授权和发送消息'>Step4：updateAndTrigger 请求授权和发送消息</a></li>
</ul>
</li>
<li><a href='#ms-customer-authorization-4.接口TokenService'>4. 接口TokenService</a>
<ul class='toc-indentation'>
<li><a href='#ms-customer-authorization-4.1INBTokenServiceImpl'>4.1 INBTokenServiceImpl</a></li>
<li><a href='#ms-customer-authorization-4.2BVTokenServiceImpl'>4.2 BVTokenServiceImpl</a></li>
<li><a href='#ms-customer-authorization-4.3MBSSTokenServiceImpl'>4.3 MBSSTokenServiceImpl</a></li>
<li><a href='#ms-customer-authorization-4.4OSPLTokenServiceImpl'>4.4 OSPLTokenServiceImpl</a></li>
</ul>
</li>
<li><a href='#ms-customer-authorization-5.接口AuthorizationStrategy'>5. 接口AuthorizationStrategy</a>
<ul class='toc-indentation'>
<li><a href='#ms-customer-authorization-5.1.接口SMSService'>5.1. 接口SMSService</a></li>
<li><a href='#ms-customer-authorization-5.2.接口SoftTokenService'>5.2. 接口SoftTokenService</a></li>
<li><a href='#ms-customer-authorization-5.3.接口HardTokenService'>5.3. 接口HardTokenService</a></li>
</ul>
</li>
<li><a href='#ms-customer-authorization-6.TriggerServiceImpl'>6. TriggerServiceImpl</a>
<ul class='toc-indentation'>
<li><a href='#ms-customer-authorization-1.preHandle()'>1. preHandle()</a></li>
<li><a href='#ms-customer-authorization-2.triggerAuthorization()'>2. triggerAuthorization()</a></li>
<li><a href='#ms-customer-authorization-3.triggerAuthzService()'>3. triggerAuthzService()</a></li>
<li><a href='#ms-customer-authorization-4.handle()'>4. handle()</a></li>
<li><a href='#ms-customer-authorization-5.checkForAuthTypeChannel()'>5. checkForAuthTypeChannel()</a></li>
</ul>
</li>
<li><a href='#ms-customer-authorization-响应'>响应</a></li>
</ul>
</li>
<li><a href='#ms-customer-authorization-API/tac/validate'>API /tac/validate</a>
<ul class='toc-indentation'>
<li><a href='#ms-customer-authorization-1.TACValidateServiceImpl'>1. TACValidateServiceImpl</a>
<ul class='toc-indentation'>
<li><a href='#ms-customer-authorization-step1，查询AUTHZ_TXN表。'>step1，查询AUTHZ_TXN表。</a></li>
<li><a href='#ms-customer-authorization-step2，根据AUTHZ_REF_CHECK配置和authz_policy表'>step2，根据AUTHZ_REF_CHECK配置和authz_policy表</a></li>
<li><a href='#ms-customer-authorization-step3，使用TxnUtl类checkDurationFlow()'>step3，使用TxnUtl类checkDurationFlow()</a></li>
<li><a href='#ms-customer-authorization-step4，使用了AuthorizationStrategy及其具体实现类'>step4，使用了AuthorizationStrategy及其具体实现类</a></li>
<li><a href='#ms-customer-authorization-step5，根据校验结果，更新AUTHZ_TXN表。'>step5，根据校验结果，更新AUTHZ_TXN表。</a></li>
</ul>
</li>
<li><a href='#ms-customer-authorization-2.MessageServiceImpl'>2. MessageServiceImpl</a></li>
</ul>
</li>
<li><a href='#ms-customer-authorization-API/otp/request'>API /otp/request</a>
<ul class='toc-indentation'>
<li><a href='#ms-customer-authorization-step1，通过请求头request.mobileNo是否为空，判断是通过SMS还是Email发送OTP。'>step1，通过请求头request.mobileNo是否为空，判断是通过SMS还是Email发送OTP。</a></li>
<li><a href='#ms-customer-authorization-step2，通过MessageServiceImpl类isEligibleForTriggering()，判断当前的AUTHZ_STS_CD状态字段，是否有资格/允许发送OTP。'>step2，通过MessageServiceImpl类isEligibleForTriggering()，判断当前的AUTHZ_STS_CD状态字段，是否有资格/允许发送OTP。</a></li>
<li><a href='#ms-customer-authorization-step3，通过GenericUtility类generateOTP()，产生OTP，并计算hash值。产生参考码AuthReference，是否有条件？'>step3，通过GenericUtility类generateOTP()，产生OTP，并计算hash值。产生参考码AuthReference，是否有条件？</a></li>
<li><a href='#ms-customer-authorization-step4，通过AuthorizationPolicyCache类从本地缓存或者AUTHZ_POLICY表查询配置，设置OTP的有效时长。'>step4，通过AuthorizationPolicyCache类从本地缓存或者AUTHZ_POLICY表查询配置，设置OTP的有效时长。</a></li>
<li><a href='#ms-customer-authorization-step5，更新AUTHZ_TXN表。'>step5，更新AUTHZ_TXN表。</a></li>
<li><a href='#ms-customer-authorization-step6，通过NotificationService类send()方法，发送消息。实际通过ms-customer-notification-sdk。'>step6，通过NotificationService类send()方法，发送消息。实际通过ms-customer-notification-sdk。</a></li>
</ul>
</li>
<li><a href='#ms-customer-authorization-API/otp/validate'>API /otp/validate</a>
<ul class='toc-indentation'>
<li><a href='#ms-customer-authorization-step1，通过请求头的authID，查询AUTHZ_TXN表。'>step1，通过请求头的auth ID，查询AUTHZ_TXN表。</a></li>
<li><a href='#ms-customer-authorization-step2，预校验。校验请求头字段和表记录是否一致，包括transactionID，参考码。'>step2，预校验。校验请求头字段和表记录是否一致，包括transactionID，参考码。</a></li>
<li><a href='#ms-customer-authorization-step3，通过比较请求头的otp和表记录的otp，进行hash校验。'>step3，通过比较请求头的otp和表记录的otp，进行hash校验。</a></li>
<li><a href='#ms-customer-authorization-step4，根据校验结果，更新AUTHZ_TXN表。'>step4，根据校验结果，更新AUTHZ_TXN表。</a></li>
</ul>
</li>
<li><a href='#ms-customer-authorization-API/otp/daily-limit-check'>API /otp/daily-limit-check</a></li>
<li><a href='#ms-customer-authorization-API/v3/access-elevation/request'>API /v3/access-elevation/request</a>
<ul class='toc-indentation'>
<li><a href='#ms-customer-authorization-1.AccessElevationRequestServiceImpl'>1. AccessElevationRequestServiceImpl</a>
<ul class='toc-indentation'>
<li><a href='#ms-customer-authorization-预处理'>预处理</a></li>
<li><a href='#ms-customer-authorization-Step1，获取用户的可用token列表'>Step1，获取用户的可用token列表</a></li>
<li><a href='#ms-customer-authorization-Step2：decideAuthorizationType判断（用户可选的）授权类型'>Step2：decideAuthorizationType 判断（用户可选的）授权类型</a></li>
<li><a href='#ms-customer-authorization-Step3：updateAndTrigger请求授权和发送消息'>Step3：updateAndTrigger 请求授权和发送消息</a></li>
</ul>
</li>
</ul>
</li>
<li><a href='#ms-customer-authorization-API/v3/access-elevation/validate'>API /v3/access-elevation/validate</a>
<ul class='toc-indentation'>
<li><a href='#ms-customer-authorization-1.AccessElevationValidateServiceImpl'>1. AccessElevationValidateServiceImpl</a>
<ul class='toc-indentation'>
<li><a href='#ms-customer-authorization-step1，通过请求头的authID，查询AUTHZ_TXN表。.1'>step1，通过请求头的auth ID，查询AUTHZ_TXN表。</a></li>
<li><a href='#ms-customer-authorization-step2，预校验。校验当前状态。'>step2，预校验。校验当前状态。</a></li>
<li><a href='#ms-customer-authorization-step3，使用了AuthorizationStrategy及其具体实现类validateAuthorization()'>step3，使用了AuthorizationStrategy及其具体实现类validateAuthorization()</a></li>
<li><a href='#ms-customer-authorization-step4，校验后处理'>step4，校验后处理</a></li>
</ul>
</li>
</ul>
</li>
<li><a href='#ms-customer-authorization-API/internal/access-elevation/shadow/validate'>API /internal/access-elevation/shadow/validate</a></li>
<li><a href='#ms-customer-authorization-AuthenticationContext上下文类'>AuthenticationContext 上下文类</a></li>
<li><a href='#ms-customer-authorization-CommonContext'>CommonContext</a></li>
<li><a href='#ms-customer-authorization-API/mfa/login-mode'>API /mfa/login-mode</a></li>
<li><a href='#ms-customer-authorization-API/mfa/otp'>API /mfa/otp</a></li>
<li><a href='#ms-customer-authorization-APIGET/mfa/token/preference'>API GET /mfa/token/preference</a></li>
<li><a href='#ms-customer-authorization-APIGET/tac/limits'>API GET /tac/limits</a></li>
<li><a href='#ms-customer-authorization-API/tac/authorization-status/retrieve'>API /tac/authorization-status/retrieve</a></li>
</ul>
</li>
<li><a href='#ms-customer-authorization-主要业务流程'>主要业务流程</a></li>
<li><a href='#ms-customer-authorization-主要架构设计方案'>主要架构设计方案</a></li>
<li><a href='#ms-customer-authorization-主要数据库设计'>主要数据库设计</a></li>
<li><a href='#ms-customer-authorization-遇到的问题和解决方案'>遇到的问题和解决方案</a></li>
<li><a href='#ms-customer-authorization-优缺点和改进方案分析，业界对比'>优缺点和改进方案分析，业界对比</a></li>
</ul>
</div></p><h2 id="ms-customer-authorization-服务描述">服务描述</h2><p>该服务主要负责授权和鉴权。鉴权类型AuthType包括SMS OTP，EMAIL OTP，SWK， HWK，FIDO。</p><h2 id="ms-customer-authorization-主要API">主要API</h2><p><span style="color: rgb(0,0,0);">梳理每个API的主要流程和架构，其中使用到的类/接口，表/字段，实体/字段等。</span></p><p><span style="color: rgb(255,0,0);">为什么ms-customer-authorization这么复杂？</span></p><p><span style="color: rgb(0,0,0);">纵向，某些接口的流程长。大步骤里面小步骤。设计和实现上没有做到高聚合。</span></p><p><span style="color: rgb(0,0,0);">横向，在channel和toke type两个维度上扩展。</span></p><p><span style="color: rgb(0,0,0);">问题一是耦合在一起，核心功能和非核心功能耦合，不同的业务耦合。</span></p><p><span style="color: rgb(0,0,0);">问题二是抽象不够？没有把共用的功能，核心的功能抽象出来。而是大量使用IF ELSE和配置项实现。</span></p><p><span style="color: rgb(255,0,0);">有没有合理和不合理的地方？</span></p><p><span style="color: rgb(255,0,0);">架构设计的角度，可以优化复杂度吗？</span></p><p><span style="color: rgb(255,0,0);"><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">纵向，</span>如果准备阶段的步骤，只和channel有关，考虑分离出去，比如放到ms-customer-authorization-inb实现，互不影响。</span></span></p><p><span style="color: rgb(255,0,0);"><span style="color: rgb(0,0,0);">另外，这些步骤之间，是否有依赖关系，如果没有，可以使用异步任务实现。</span></span></p><p><span style="color: rgb(255,0,0);"><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">横向，</span>把共用的功能抽取出来放到抽象类实现，或者放到default具体实现类，把个性化的功能放到具体实现类。区分开共用的功能和个性化的功能，进行解耦。</span></span></p><p><span style="color: rgb(255,0,0);">3ds和assisted-channel与其他代码的关系？是否可以剥离出去？把只和channel先关的业务，剥离到domian service实现，而不是放到core service层实现。</span></p><p><span style="color: rgb(255,0,0);">/mfa/token/*接口是否与ms-token-mgn功能重合？是否可以剥离？</span></p><p><br/></p><h2 id="ms-customer-authorization-"><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="attachments/6389763/6389764.png" data-image-src="http://confluence.txw.com:9090/download/attachments/6389763/image2023-9-19_22-40-38.png?version=1&amp;modificationDate=1695134439000&amp;api=v2"></span></h2><h3 id="ms-customer-authorization-分析"><strong>分析</strong></h3><p><strong>1、上图中TokenService接口，主要方法包括queryUserProfile()和decideAuthoizationType()，按照Channel维度分别有具体实现类。</strong></p><p>queryUserProfile()方法是查询用户信息。查询用户信息包括token信息，但不依赖于token维度。</p><p>decideAuthoizationType()方法是计算用户的最终授权类型。需要综合计算用户的可用授权类型、配置授权类型。</p><p><strong>因为这两个方法主要依赖于Channel维度，所以用该接口设计实现。</strong></p><p><span style="color: rgb(255,0,0);"><strong>这2个方法真的只<strong>依赖于Channel维度？<span style="color: rgb(0,0,0);">基本上是。</span></strong></strong></span></p><p><span style="color: rgb(255,0,0);"><strong><strong>为什么不把prepareRequestDetail()方法，也放入该接口？<span style="color: rgb(0,0,0);">该方法是获取交易类型TXN Type的配置信息。</span></strong></strong></span></p><p><span style="color: rgb(255,0,0);"><strong><strong><br/></strong></strong></span></p><p><strong>2、上图中AuthorizationStrategy接口，实现了2个维度的扩展，分别是Token类型（SMS、Email、SWK、HWK）和Channel（INB、BV、MBSS）。</strong></p><p>主要方法包括triggerAuthorization()和validateAuthorization()。</p><p>triggerAuthorization()方法用于/request接口的触发消息逻辑，包括SMS、Email、SWK。</p><p>和validateAuthorization()方法用于/valildate接口的校验逻辑。</p><p><strong><strong><strong>因为这两个方法同时依赖于<strong>Token类型和C</strong>hannel维度，所以使用该接口这种设计实现<strong>2个维度的扩展</strong>。</strong></strong></strong></p><p><strong><strong><br/></strong></strong></p><h3 id="ms-customer-authorization-API/tac/request"><strong>API /tac/request</strong></h3><h4 id="ms-customer-authorization-1.TwoStepElevationController">1. TwoStepElevationController</h4><p>控制器层，目前提供了v1/v2/v3的不同版本。</p><p>提供了所有的核心功能的接口，包括/tac/request，/tac/validate，access-elevation/request，access-elevation/validate等。</p><h4 id="ms-customer-authorization-2.TwoStepElevationServiceImpl">2. TwoStepElevationServiceImpl</h4><h5 id="ms-customer-authorization-服务层，主要方法tacRequest()">服务层，主要方法tacRequest()</h5><p>根据请求头，创建AuthenticationContext，设置tacRequest，mfaType，challengeCode，triggerOTP，transactionPayload字段。</p><h4 id="ms-customer-authorization-3.TACRequestServiceImpl">3. TACRequestServiceImpl</h4><p>TAC Request流程的具体实现类。</p><p>主要方法handle()，包括4个步骤。</p><h5 id="ms-customer-authorization-预处理：">预处理：</h5><p>判断是否passthrough还是standalone，是否pilot user mode。</p><p>根据请求传参，设置AuthenticationContext的<strong>challengeCode</strong>和<strong>customerChallengeCode</strong>字段。</p><p>根据channel，设置AuthenticationContext的<strong>identity</strong>字段（决定<strong>AuthorizationStrategy接口的具体实现类</strong>）。</p><p><br/></p><p>以下步骤以INBTokenServiceImpl为例</p><h5 id="ms-customer-authorization-Step1：getUserProfile获取用户和token信息"><span style="color: rgb(0,0,0);">Step1：getUserProfile <strong>获取用户和token信息</strong></span></h5><p>通过查询缓存，数据库，调用下游service或SOA等，获取用户信息和用户可用的token信息，并设置AuthenticationContext的<strong>authorizerTokenEntity</strong>字段（对应<strong>AUTHZ_USER_PROFILE</strong>表）。</p><p>使用了<strong>TokenService</strong>的具体实现类的queryUserProfile()方法。</p><p>涉及查询<strong>AUTHZ_USER_PROFILE</strong>表。</p><p>f1异步调用SOA（UAS-QueryUser）→ <strong>iSprint/UAS-QueryUser</strong>，获取SWK用户信息，并设置<strong>AuthorizerTokensEntity</strong>的isprintUserStatusCode，isprintLoginAccountStatusCode，isSwkSvcDown，<strong>custom</strong>（SWK_LOGIN_MODULE_ID，SWK_BAD_LOGIN_COUNT, TokenStepUpRequestDate, TokenStepUpExpiryDate, AfterCoolingPeriodToVerifyOTP）等字段。</p><p>f2异步调用SOA（UAS-QueryToken）→ <strong>iSprint/UAS-QueryToken</strong>，获取SWK用户soft token信息，并设置<strong>AuthorizerTokensEntity</strong>的softTokenStatusCode，deviceFingerPrint，deviceOSName，Tid，softTokenSerialNo，pkiTokenSerialNo，<strong>custom</strong>（SWK_STATUS，USP_COOLING_PERIOD_STARTDT）等字段。</p><p><strong>DSSS</strong></p><p>f3异步调用SOA（2FA-QueryUser-I）→ <strong>DSSS/2FA-QueryUser-I</strong>，获取SMS/HWK用户信息，并设置<strong>AuthorizerTokensEntity</strong>的userStatusCode，custom（DSSS_USER_STATUS，DSSS_OTP_TOKEN_FAILED_TRIES）。废弃。</p><p>f3异步调用SOA（2FA-GetTokenReqStatus-I）→ <strong>DSSS/2FA-GetTokenReqStatus-I</strong>，获取SMS/HWK用户token信息，设置<strong>AuthorizerTokensEntity</strong>的smsTokenStatusCode，hardTokenStatus，hwkSerialNo，custom（HARD_TOKEN_REQUEST_STATE，）等字段。</p><p>f4异步调用SOA（Auth_Inquiry_2FAMediaDestination）→ <strong>?/Auth_Inquiry_2FAMediaDestination</strong>，并设置<strong>AuthorizerTokensEntity</strong>的mobileNo字段。</p><p><strong>CAS</strong></p><p>f3异步调用ms-token-mgn/internal/tfa/users/retrieve，获取SMS/HWK用户信息。</p><p>f4空</p><p><br/></p><p>f5异步调用INB USP，获取accessCode, tokenType，coolingPeriodStartDt，gracePeriodIndicator，AfterCoolingPeriodToVerifyOTP，AfterCoolingPeriodToVerifyHighRisk。</p><p><span style="color: rgb(255,0,0);">TBC=====================</span></p><h5 id="ms-customer-authorization-Step2：prepareRequestDetail获取交易类型的配置信息，同步最新数据"><span style="color: rgb(0,0,0);">Step2：prepareRequestDetail 获取交易类型的配置信息，同步最新数据</span></h5><p>通过TXN Type，查询缓存和<strong>TAC</strong>表，<strong>customer_tac</strong>表？</p><p>这一步骤和TXN Type有关。在TAC Request的流程中有TXN Type，所以有这一步骤。而在2FA Request的流程中没有TXN Type，所以没有这一步骤。</p><p>调用<strong>SyncTransactionDataService</strong>类具体实现类的<strong>sync</strong>()方法，从<strong>Old Car</strong>同步最新TAC相关数据。</p><p>设置AuthorizationContext的authorizationType，<strong>tacEntity</strong>，highRiskFlag，extraAuthorizationType，mfaId，transactionType，gtSigningMode，ltSigningMode字段。</p><p>更新<strong>AUTHZ_POLICY</strong>表？</p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image confluence-external-resource" height="250" src="attachments/6389763/6389801.png" data-image-src="http://confluence.txw.com:9090/download/attachments/6389763/image2023-9-26_23-25-24.png?version=1&amp;modificationDate=1695741925000&amp;api=v2"></span></p><p><strong>分析：</strong></p><p><strong>1、上图中TACRequestServiceImpl类需要用到SysnTransactionDataServcie接口同步数据。</strong></p><p><strong><strong>2、SysnTransactionDataServcie接口按照Channel维度分别有不同的具体实现类，不同Channel的同步数据的逻辑不同。</strong></strong></p><p><strong><br/></strong></p><p><strong>注意：</strong></p><p><strong>AUTHZ_POLICY</strong>授权类型的配置表，Channel and Auth Type level。</p><p><strong>TAC</strong>交易类型和授权类型的配置表，Channel and Transaction Type level。</p><p><strong>步骤：</strong></p><p>1. 通过syncTransactionDataService.syncData()，从old car同步TAC数据。</p><p>2. 根据TXN_RULE_MAPPING表设置，校验请求体的必填字段。</p><p>3. 判断并设置<span>配置的授权类型</span><strong>initialAuthorizations、TACEntity、HighRiskFlag。</strong></p><p><br/></p><p>注：该方法逻辑和channel有关，特别是syncTransactionDataService.syncData()。</p><p><br/></p><h5 id="ms-customer-authorization-Step3：decideAuthorizationType判断（用户可选的）授权类型"><span style="color: rgb(0,0,0);">Step3：decideAuthorizationType <strong>判断（用户可选的）授权类型</strong></span></h5><p>使用了<strong>TokenService</strong>及其具体实现类。</p><p>设置AuthorizationContext的requireChallengeCode，availableAuthType，swkFirstLogin，finalAuthorizationType，softTokenStepUpRequired字段。</p><div class="table-wrap"><table class="fixed-table confluenceTable"><colgroup><col style="width: 67.0px;"/><col style="width: 74.0px;"/><col style="width: 908.0px;"/></colgroup><tbody><tr><th class="confluenceTh">Region</th><th class="confluenceTh">Channel</th><th class="confluenceTh">Flow</th></tr><tr><td class="confluenceTd">SG</td><td class="confluenceTd">BV</td><td class="confluenceTd"><p>1. 通过<strong>queryUserProfile</strong>()，获取用户的可用授权类型数组<strong>activeAuthType</strong>。</p><p>2. 从request.preferredToken获取用户的期望的授权类型，可以为空。</p><p>3. 按照channel和TxnType，在<strong>prepareRequestDetail</strong>()，获取配置的授权类型<strong>initialAuthorizations=authContext.getAuthorizationType()</strong>。</p><p>3.1 通过DB或bv-snapshot，通过<span>channel和TxnType查询<strong>TAC</strong>表。</span></p><p><span>https://bv-snapshot-sg.apps.ocbc.com/v1/tac/{transactionType}/limits</span></p><p><span>3.2 检查request body的payload。</span></p><p><span>3.3 检查amount。</span></p><p><span>4. 在<strong>decideAuthorizationType</strong>()，比较配置的<span>授权类型<strong>initialAuthorizations</strong>和<span>可用授权类型<strong>activeAuthType</strong>，</span></span></span></p><p><span><span><span>得到最终的授权类型<strong>FinalAuthType</strong>。把<strong>activeTokenList</strong>转为字符串得到<strong>availableAuthType</strong>，并返回。</span></span></span></p><p><span><span><span><br/></span></span></span></p></td></tr><tr><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd">INB</td><td colspan="1" class="confluenceTd"><p><span style="color: rgb(0,0,0);"><strong>decideAuthorizationType()</strong><br/></span></p><p><span style="color: rgb(0,0,0);">1. 获取authContext.highRiskFlag。</span></p><p><span style="color: rgb(0,0,0);">2. 根据highRiskFlag，获取signingMode。</span></p><p><span style="color: rgb(0,0,0);">3. 如果signingMode=OCRA*，设置authContext.requireChallengeCode=YES。</span></p><p><span style="color: rgb(0,0,0);">4. 通过messageService.getMaxCountFromPolicy()，设置authContext.smsMaxCount，从<strong>AUTHZ_POLICY</strong>表获取短信最大重发次数。</span></p><p><span style="color: rgb(0,0,0);">5. 比较配置的授权类型<strong>initialAuthorizations</strong>和可用授权类型列表<strong>activeTokenList，得到最终的授权类型<strong>FinalAuthType</strong>。</strong></span></p><p><span style="color: rgb(0,0,0);"><strong>6. 如果<strong>FinalAuthType=SWK，则<strong>activeTokenList只保留SWK。</strong></strong></strong></span></p></td></tr><tr><td colspan="1" class="confluenceTd"><br/></td><td colspan="1" class="confluenceTd">MBSS</td><td colspan="1" class="confluenceTd"><p><span style="color: rgb(0,0,0);"><strong>decideAuthorizationTypeV2()</strong></span></p><p><br/></p></td></tr></tbody></table></div><p><strong>注：以下是BV的版本。</strong></p><p><strong>swkFirstTimeLoginCheck() - 检查是否是SWK的FirstTimeLogin。</strong></p><p><strong>步骤</strong>：</p><p><strong>如果是2FA流程</strong>，而且<span>最终的授权类型</span><strong>FinalAuthType是SWK。</strong></p><p><strong>如果authContext.isBvEnableFirstTimeSWKLogin &amp;&amp; authorizerTokenEntity.custom.IS_SWK_FIRST_LOGIN。</strong></p><p><strong>如果authContext.request.functionCode not in oobSwkInEligibleFunctioncodes。</strong></p><p>设置<strong>authContext.extraAuthType</strong>=SWK。</p><p>设置<strong>authContext.swkFirstLogin</strong>=true。</p><p><strong>注：<strong>authContext.<strong>swkFirstLogin</strong>字段受到user level（authorizer.custom.<strong>IS_SWK_FIRST_LOGIN</strong>）影响。</strong></strong></p><p><strong><br/></strong></p><p><strong>oobCheck() - </strong><strong style="letter-spacing: 0.0px;">检查是否是SWK的FirstTimeTxn。</strong></p><p><strong style="letter-spacing: 0.0px;">步骤：<br/></strong></p><p><strong>如果是TAC流程</strong>，而且最终的授权类型<strong>FinalAuthType</strong>是SWK或者TAC.ExtraStepAuth=SWK。</p><p>查询authPolicy。</p><p>通过请求头deviceInfo.fpt||tid不为空，则为mobile。</p><p>如果请求来自mobile，则判断<strong>authPolicy.isMobileSWKFirstTimeSignOTP</strong>，否则判断<strong>authPolicy.isWebSWKFirstTimeSignOTP</strong>。</p><p>如果<strong>TAC.FirstTimeSWKTxnCheck</strong>为true。</p><p>如果<strong>authorizer.custom.IS_SWK_FIRST_TXN</strong>为true。</p><p>设置<strong>authContext.swkFirstTxn</strong>=true。</p><p><strong>注：authContext.swkFirstTxn字段受到user level（authorizer.custom.<strong>IS_SWK_FIRST_TXN</strong>）、txn level（TAC）、authType level（AUTHZ_POLICY.<strong>isWebSWKFirstTimeSignOTP|<strong>isMobileSWKFirstTimeSignOTP</strong></strong>）共同影响。</strong></p><p><strong><br/></strong></p><p><strong>decideRequireChallengeCode() - 判断是否需要Challenge Code。</strong></p><p><strong>BV版本</strong></p><p><strong>步骤：</strong></p><p>如果<strong>authContext.triggerOTP</strong>=YES。</p><p>如果<strong>mfaType</strong>=TAC。</p><p>如果最终的授权类型<strong>FinalAuthType</strong>是SWK且<strong>tacSWKOverrideSigningMode</strong>=OCRA1) 或HWK且<strong>tacHWKOverrideSigningMode</strong>=OCRA1)。</p><p>设置<strong>authContext.requireChallengeCode</strong>=YES。</p><p>设置<strong>overrideFlag。</strong></p><p>通过配置文件：tacSWKOverrideSigningMode=OCRA1，tacHWKOverrideSigningMode=OCRA1</p><p>不再需要后续判断authContext.highRisk和authPolilcy判断。</p><p><br/></p><p>如果overrideFlag=true，返回。</p><p>如果overrideFlag=false。</p><p>如果最终的授权类型<strong>FinalAuthType</strong>是SWK或者HWK。</p><p>如果<strong>authContext.highRiskFlag</strong>=YES，<strong>signingMode</strong>=authContext.gtSigningMode。</p><p>如果authContext.highRiskFlag=NO，signingMode=authContext.ltSigningMode。</p><p>如果signingMode是（NONE，OCRA1，OCRA2）。</p><p><strong>设置authContext.requireChallengeCode=YES。</strong></p><p><br/></p><p>注：以上几个方法都需要用最终的授权类型<strong>FinalAuthType判断，所以放在</strong><span style="color: rgb(0,0,0);">decideAuthorizationType()。</span></p><p><span style="color: rgb(0,0,0);"><br/></span></p><p><strong><span style="color: rgb(0,0,0);">以下是INB的版本，</span></strong></p><p><span style="color: rgb(0,0,0);">和BV版本比较，同样有FirstTimeLogin的判断。没有FirstTimeTxn的判断。没有<span style="color: rgb(0,0,0);">requireChallengeCode的判断。</span><span style="color: rgb(0,0,0);">多了是否需要stepup的判断。<span style="color: rgb(0,0,0);">多了是否在冷静期coolingperiod的判断。</span></span></span></p><p><span style="color: rgb(0,0,0);"><strong>步骤：</strong></span></p><p><span style="color: rgb(0,0,0);">1. 获取authContext.highRiskFlag。</span></p><p><span style="color: rgb(0,0,0);">2. 根据highRiskFlag，获取signingMode。</span></p><p><strong><span style="color: rgb(0,0,0);">3. 如果signingMode=OCRA*，设置authContext.requireChallengeCode=YES。</span></strong></p><p><span style="color: rgb(0,0,0);">4. 通过messageService.getMaxCountFromPolicy()，设置authContext.smsMaxCount，从<strong>AUTHZ_POLICY</strong>表获取短信最大重发次数。</span></p><p><span style="color: rgb(0,0,0);">5. 比较<span>配置的</span><span>授权类型<strong>initialAuthorizations</strong>和</span>可用授权类型列表<strong>activeTokenList，<span>得到最终的授权类型</span><strong>FinalAuthType</strong>。</strong></span></p><p><span style="color: rgb(0,0,0);">messageService.verifySpecificAuthzTypeByConfig(authContext, activeTokenList)</span></p><p><span style="color: rgb(0,0,0);">messageService.verifySpecificAuthzTypeForOCRA(authContext, activeTokenList)</span></p><p><span style="color: rgb(0,0,0);">messageService.verifySpecificAuthzTypeForTOTP(authContext, activeTokenList)<strong><br/></strong></span></p><p><span style="color: rgb(0,0,0);"><strong>6. 如果<strong>FinalAuthType=SWK，则<strong>activeTokenList只保留SWK。</strong></strong></strong></span></p><p><span style="color: rgb(0,0,0);"><strong><br/></strong></span></p><p><span style="color: rgb(0,0,0);"><strong>checkSWKFirstLogin()<strong> - 检查是否是SWK的FirstTimeLogin</strong></strong></span></p><p><span style="color: rgb(0,0,0);">如果channel是INB或MBS，mfaType是access-elevation，finalAuthTye是SWK。</span></p><p><span style="color: rgb(0,0,0);">如果已经过了冷静期，如果是SG，</span></p><p><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">如果是INB 共存模式，</span>获取</span><span style="color: rgb(0,0,0);">authorizer.custom.afterCoolingPeriodToVerifyOTP</span></p><p>如果不是INB共存模式，获取<span style="color: rgb(0,0,0);">authorizer.custom.AfterCoolingPeriodToVerifyOTP</span></p><p><strong><span style="color: rgb(0,0,0);">设置authContext.swkFirstLogin</span>=<span style="color: rgb(0,0,0);">afterCoolingPeriodToVerifyOTP|<span style="color: rgb(0,0,0);">AfterCoolingPeriodToVerifyOTP。</span></span></strong></p><p><span style="color: rgb(0,0,0);"><strong><strong><strong>如果是SWK的FirstTimeLogin，</strong>设置<strong>FinalAuthType=SMS_OTP。activeTokenList和SMS_OTP做交集。</strong></strong></strong></span></p><p><span style="color: rgb(0,0,0);"><strong><strong><strong><br/></strong></strong></strong></span></p><p><span style="color: rgb(0,0,0);"><strong><strong>checkSWKFirstCoolingPeriod() - 检查是否过了冷静期</strong></strong></span></p><p><span style="color: rgb(0,0,0);">获取<span style="color: rgb(0,0,0);">authorizer.gracePeriodIndicator。</span></span></p><p><span style="color: rgb(0,0,0);">获取authorizer.custom.coolingPeriodStartDt。如果为空则获取<span style="color: rgb(0,0,0);">authorizer.tokenStepUpDate。</span></span></p><p><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">如果<span style="color: rgb(0,0,0);">gracePeriodIndicator=false或者<span style="color: rgb(0,0,0);">coolingPeriodStartDt为空，则返回false，表示不在冷静期。</span></span></span></span></p><p><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">通过<span style="color: rgb(0,0,0);">coolingPeriodStartDt和期限配置（15min UAT/12hr Prod），计算是否在冷静期。</span></span></span></span></span></p><p><span style="color: rgb(0,0,0);"><strong><strong><span style="color: rgb(0,0,0);">如果是SG，如果在冷静期则返回false</span><strong>，如果不在冷静期，则返回<strong>true。</strong></strong></strong></strong></span></p><p><span style="color: rgb(0,0,0);"><strong><strong>如果是MY，如果在冷静期则抛出异常，如果不在冷静期，则返回true。</strong></strong></span></p><p><span style="color: rgb(0,0,0);"><strong><strong><br/></strong></strong></span></p><p><span style="color: rgb(0,0,0);"><strong>checkSWKStepUpStatus() - 检查是否是SWK的StepUp状态</strong></span></p><p><span style="color: rgb(0,0,0);">如果是TAC，signingMode=OCRA*，FinalAuthType=SWK</span></p><p><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">获取</span><span style="color: rgb(0,0,0);">authorizer.custom.ISprintSWKStatus。</span></span></p><p><span style="color: rgb(0,0,0);"><strong>如果ISprintSWKStatus=ACTIVATED，设置authContext.softTokenStepUpRequired=true，并返回。</strong></span></p><p><strong><span style="color: rgb(0,0,0);">如果ISprintSWKStatus=ELEVATED而且还在冷静期，抛出异常SWK_IN_COOLING_PERIOD。</span></strong></p><p><span style="color: rgb(0,0,0);"><strong><strong><strong><br/></strong></strong></strong></span></p><p><span style="color: rgb(0,0,0);"><strong><strong><strong>INB SWK的状态</strong></strong></strong></span></p><p><span style="color: rgb(0,0,0);"><strong><strong><strong>安装SWK provision_-&gt;未激活<strong>-&gt;</strong>已激活<strong>ACTIVATED</strong>/未升级<strong>-&gt;</strong>已升级<strong><span style="color: rgb(0,0,0);">ELEVATED<strong>-&gt;</strong></span></strong>还在冷静期<strong><span style="color: rgb(0,0,0);">IN_COOLING_PERIOD<strong>-&gt;</strong></span></strong>已过冷静期AFTER<strong><span style="color: rgb(0,0,0);">_COOLING_PERIOD<strong>-&gt;</strong></span></strong>第一次登录使用<strong>FirstTimeLogin</strong>（<strong><strong>设置<strong>FinalAuthType=SMS_OTP，</strong></strong></strong>发送短信）。</strong></strong></strong></span></p><p><span style="color: rgb(0,0,0);"><br/></span></p><p><strong><span style="color: rgb(0,0,0);">以下是MBSS的版本，</span></strong></p><p><span style="color: rgb(0,0,0);">和BV版本的比较，同样有是否需要requireChallengeCode的判断。<span style="color: rgb(0,0,0);">没有<span style="color: rgb(0,0,0);">FirstTimeLogin和</span>FirstTimeTxn的判断。</span></span></p><p><span style="color: rgb(0,0,0);"><strong>步骤：</strong></span></p><p><span style="color: rgb(0,0,0);">1. 获取authContext.highRiskFlag。</span></p><p><span style="color: rgb(0,0,0);">2. 根据highRiskFlag，获取signingMode。</span></p><p><strong><span style="color: rgb(0,0,0);">3. 如果signingMode=OCRA*，设置authContext.requireChallengeCode=YES。</span></strong></p><p><span style="color: rgb(0,0,0);">4. 通过messageService.getMaxCountFromPolicy()，设置authContext.smsMaxCount，从<strong>AUTHZ_POLICY</strong>表获取短信最大重发次数。</span></p><p><span style="color: rgb(0,0,0);">5. 比较配置的授权类型<strong>initialAuthorizations</strong>和可用授权类型列表<strong>activeTokenList，得到最终的授权类型<strong>FinalAuthType</strong>。</strong></span></p><p><br/></p><p><span style="color: rgb(0,0,0);">messageService.verifySpecificAuthzTypeByConfig(authContext, activeTokenList)</span></p><p><br/></p><p><span style="color: rgb(0,0,0);">messageService.verifySpecificAuthzTypeForOCRA(authContext, activeTokenList)</span></p><p><br/></p><p><span style="color: rgb(0,0,0);">messageService.verifySpecificAuthzTypeForTOTP(authContext, activeTokenList)</span></p><p><span style="color: rgb(0,0,0);"><strong>6. 如果<strong>FinalAuthType=SWK，则<strong>activeTokenList只保留SWK。</strong></strong></strong></span></p><p><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><br/></span></span></p><div class="table-wrap"><table class="fixed-table confluenceTable"><colgroup><col style="width: 74.0px;"/><col style="width: 161.0px;"/><col style="width: 150.0px;"/><col style="width: 223.0px;"/><col style="width: 122.0px;"/><col style="width: 197.0px;"/></colgroup><tbody><tr><th class="confluenceTh">Channel</th><th class="confluenceTh"><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">是否是</span>FirstTimeLogin</span></th><th class="confluenceTh"><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);">是否是</span>FirstTimeTxn</span></th><th class="confluenceTh"><span style="color: rgb(0,0,0);">是否需要requireChallengeCode</span></th><th colspan="1" class="confluenceTh"><span style="color: rgb(0,0,0);">是否需要stepup</span></th><th colspan="1" class="confluenceTh"><span style="color: rgb(0,0,0);">是否在冷静期coolingperiod</span></th></tr><tr><td class="confluenceTd"><strong>BV</strong></td><td style="text-align: center;" class="confluenceTd">Y</td><td style="text-align: center;" class="confluenceTd">Y</td><td style="text-align: center;" class="confluenceTd">Y</td><td style="text-align: center;" colspan="1" class="confluenceTd">N</td><td style="text-align: center;" colspan="1" class="confluenceTd">N</td></tr><tr><td class="confluenceTd"><strong>INB</strong></td><td style="text-align: center;" class="confluenceTd">Y</td><td style="text-align: center;" class="confluenceTd">N</td><td style="text-align: center;" class="confluenceTd">Y</td><td style="text-align: center;" colspan="1" class="confluenceTd">Y</td><td style="text-align: center;" colspan="1" class="confluenceTd">Y</td></tr><tr><td class="confluenceTd"><strong>MBSS</strong></td><td style="text-align: center;" class="confluenceTd">N</td><td style="text-align: center;" class="confluenceTd">N</td><td style="text-align: center;" class="confluenceTd">Y</td><td style="text-align: center;" colspan="1" class="confluenceTd">N</td><td style="text-align: center;" colspan="1" class="confluenceTd">N</td></tr></tbody></table></div><p><span style="color: rgb(0,0,0);"><span style="color: rgb(0,0,0);"><br/></span></span></p><p><strong><br/></strong></p><h5 id="ms-customer-authorization-Step4：updateAndTrigger请求授权和发送消息"><span style="color: rgb(0,0,0);">Step4：updateAndTrigger <strong>请求授权和发送消息</strong></span></h5><p><span style="color: rgb(0,0,0);">涉及<strong>AUTHZ_TXN</strong>表。</span></p><p><span style="color: rgb(0,0,0);">调用<strong>TriggerServiceImpl</strong>类。</span></p><p><span style="color: rgb(0,0,0);">调用<strong style="letter-spacing: 0.0px;">AuthorizationStrategy</strong>及其具体实现类，比如<strong>INBSmsTokenServiceImpl</strong>类。</span></p><p><span style="color: rgb(0,0,0);">发送Kafka消息。</span></p><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image confluence-external-resource" height="250" src="attachments/6389763/6389794.png" data-image-src="http://confluence.txw.com:9090/download/attachments/6389763/image2023-9-24_23-25-11.png?version=1&amp;modificationDate=1695569112000&amp;api=v2"></span></p><p><strong>分析：</strong></p><p><strong>1、上图中TACRequestServiceImpl类需要用到TriggerServiceImpl接口实现发送数据。</strong></p><p><strong>2、<strong>TriggerServiceImpl</strong>接口按照Channel维度和Token Type维度分别有不同的具体实现类，不同<strong>具体实现类</strong>的发送数据的逻辑不同。</strong></p><p><strong><br/></strong></p><p><strong style="letter-spacing: 0.0px;"><br/>步骤：</strong></p><p>1. 获取authContext.triggerOTP。这个字段从请求体获取，默认为YES。</p><p>2. 如果为YES，构建authTxnEntity。</p><p>3. 调用triggerService.triggerAuthzService()。</p><p>3.1 如果是TAC，而且不是authContext.customChallengeCode=YES，而且authContext.requireChallengeCode=true，而且authTxnEntity.challengeCode=empty,</p><p><strong>创建并设置authContext.challengeCode，设置authContext.requireChallengeCode=YES。</strong></p><p>3.2 调用<strong>AbstractTrigger.triggerAuthorization()</strong></p><p>3.2.1 检查是否是重发mfa/otp，如果是重发，检查authType是否变化。如何检查？，对比FinalAuthTYpe和txn.authPolicy.authType</p><p>如果没有变化，检查原txn.authStatus，如果是VERIFIED已经验证或者BLOCKED则抛出异常。设置原txn.status=EXPIRED，创建新的txn记录，同下。</p><p>如果有变化，设置原txn.status=EXPIRED，创建新的txn记录（从原txn记录复制字段，包括createdBy、updatedBy）。ver+1，retryCount+1，authCount=0。如果原txn.isCustomChallengeCode=true，则直接复制原txn.challengeCode。否则重新创建challengeCode。</p><p>3.2.2 设置新txnEntity。</p><p>3.2.3 调用<strong>authorizationStrategy.triggerAuthorization()</strong></p><p>如果是HardToken，不需要cust-auth发送什么信息。</p><p>如果是SMS OTP，</p><div class="table-wrap"><table class="fixed-table confluenceTable"><colgroup><col style="width: 97.0px;"/><col style="width: 211.0px;"/><col style="width: 184.0px;"/></colgroup><tbody><tr><th class="confluenceTh">Channel</th><th class="confluenceTh"><span>创建OTP</span></th><th class="confluenceTh"><span>发送OTP</span></th></tr><tr><td class="confluenceTd"><strong>BV</strong></td><td class="confluenceTd">Invoke SSO</td><td class="confluenceTd"><span><span>Invoke</span> SSO</span></td></tr><tr><td class="confluenceTd"><strong>MBSS</strong></td><td class="confluenceTd">Standalone</td><td class="confluenceTd"><p><span>Invoke</span> ms-cust-noti</p></td></tr><tr><td class="confluenceTd"><strong>INB</strong></td><td class="confluenceTd">Invoke ms-token-mgn</td><td class="confluenceTd"><span><span>Invoke</span> ms-cust-noti</span></td></tr></tbody></table></div><p><strong>SMS OTP</strong></p><div class="table-wrap"><table class="fixed-table confluenceTable"><colgroup><col style="width: 95.0px;"/><col style="width: 127.0px;"/><col style="width: 294.0px;"/></colgroup><tbody><tr><th class="confluenceTh">Channel</th><th class="confluenceTh">创建OTP</th><th class="confluenceTh">发送OTP</th></tr><tr><td class="confluenceTd"><strong>INB</strong></td><td class="confluenceTd">SOA</td><td class="confluenceTd">ms-customer-notification</td></tr><tr><td class="confluenceTd"><strong>BV</strong></td><td class="confluenceTd">SSO</td><td class="confluenceTd">SSO</td></tr><tr><td class="confluenceTd"><strong>MBSS</strong></td><td class="confluenceTd">standalone</td><td class="confluenceTd">ms-customer-notification</td></tr></tbody></table></div><p>如果是Email OTP，</p><div class="table-wrap"><table class="fixed-table confluenceTable"><colgroup><col style="width: 98.0px;"/><col style="width: 149.0px;"/><col style="width: 186.0px;"/></colgroup><tbody><tr><th class="confluenceTh">Channel</th><th class="confluenceTh">创建OTP</th><th class="confluenceTh">发送OTP</th></tr><tr><td class="confluenceTd"><strong>INB</strong></td><td class="confluenceTd"><span>Standalone</span></td><td class="confluenceTd"><span>ms-customer-notification</span></td></tr><tr><td class="confluenceTd"><strong>BV</strong></td><td class="confluenceTd"><span>Standalone</span></td><td class="confluenceTd"><span>ms-customer-notification</span></td></tr><tr><td class="confluenceTd"><strong>MBSS</strong></td><td class="confluenceTd"><span>Standalone</span></td><td class="confluenceTd"><span>ms-customer-notification</span></td></tr></tbody></table></div><p><br/></p><p>如果是SoftToken，</p><div class="table-wrap"><table class="fixed-table confluenceTable"><colgroup><col style="width: 74.0px;"/><col style="width: 172.0px;"/><col style="width: 205.0px;"/><col style="width: 191.0px;"/><col style="width: 170.0px;"/><col style="width: 610.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><span>Channel</span></th><th class="confluenceTh">检查coolingPeriod</th><th colspan="1" class="confluenceTh"><span>检查SWKFirstTimeLogin</span></th><th colspan="1" class="confluenceTh">检查SWKFirstTimeTxn</th><th colspan="1" class="confluenceTh">检查shadowMode</th><th colspan="1" class="confluenceTh">备注</th></tr><tr><td class="confluenceTd"><strong>INB</strong></td><td class="confluenceTd">Y</td><td colspan="1" class="confluenceTd">N</td><td colspan="1" class="confluenceTd">N</td><td colspan="1" class="confluenceTd">Y</td><td colspan="1" class="confluenceTd">只是在这个步骤没有检查FirstTimeLogin和FirstTimeTxn。NotificationType=PUSH_OTP</td></tr><tr><td class="confluenceTd"><strong>BV</strong></td><td class="confluenceTd">N</td><td colspan="1" class="confluenceTd">Y</td><td colspan="1" class="confluenceTd">Y</td><td colspan="1" class="confluenceTd">Y</td><td colspan="1" class="confluenceTd"><span>NotificationType=EMAIL/PUSH_OTP_BV</span></td></tr><tr><td class="confluenceTd"><strong>MBSS</strong></td><td class="confluenceTd">Y</td><td colspan="1" class="confluenceTd">N</td><td colspan="1" class="confluenceTd">Y</td><td colspan="1" class="confluenceTd"><strong>N</strong></td><td colspan="1" class="confluenceTd"><span style="color: rgb(255,0,0);">为什么没有发送信息？</span></td></tr></tbody></table></div><p><br/></p><p><strong><span style="color: rgb(255,0,0);">=========TBC</span><br/></strong></p><p><strong><br/></strong></p><p><strong>分析：</strong></p><p><strong>1. 实际上，Step1/2/3都是为了step4的准备动作，而Step4是核心功能：请求（发送）。</strong></p><p>2. 因为TACRequest和2FARequest都有类似的准备动作，所以抽象出了AbstractRequest类。</p><p>3. 这些准备动作当中，比如queryUserProfile()和decideAuthorizationType()，<strong>同具体的channel有关，和具体的token type无关</strong>。</p><p>所以通过接口<strong>TokenService</strong>及其具体实现类，比如在<strong>INBTokenServiceImpl</strong>类等实现具体逻辑。</p><h4 id="ms-customer-authorization-4.接口TokenService">4. 接口TokenService</h4><p>该接口提供了2个方法：<strong>queryUserProfile</strong>()和<strong>decideAuthorizationType</strong>()。</p><p>该接口有4个具体实现类：INBTokenServiceImpl，BVTokenServiceImpl，MBSSTokenServiceImpl，OSPLTokenServiceImpl。</p><p><strong>注意：该接口在channel维度进行了扩展，而没有在token type维度进行扩展。</strong></p><p><span style="color: rgb(255,0,0);"><strong>因为不同的token type，在获取用户信息和判断授权类型上没有区别？</strong></span></p><h5 id="ms-customer-authorization-4.1INBTokenServiceImpl"><span style="color: rgb(0,0,0);"><strong>4.1 INBTokenServiceImpl</strong></span></h5><p>用到4张表：</p><p>TokenPreferenceRepository，调用inb数据库的存储过程</p><p>uthorizerTokenRepository，调用<strong>AUTHZ_USER_PROFILE</strong>表</p><p>TokenTypePreferenceRepository，调用cust_token_preference表</p><p>UserSmsRepository，调用USER_SMS_RECORD表</p><h5 id="ms-customer-authorization-4.2BVTokenServiceImpl"><span style="color: rgb(0,0,0);"><strong><strong>4.2 BV</strong></strong><strong style="letter-spacing: 0.0px;">TokenServiceImpl</strong></span></h5><p>用到1张表：AuthorizerTokenRepository，调用AUTHZ_USER_PROFILE表</p><h5 id="ms-customer-authorization-4.3MBSSTokenServiceImpl"><span style="color: rgb(0,0,0);"><strong>4.3 MBSS</strong><strong>TokenServiceImpl</strong></span></h5><p>用到1张表：AuthorizerTokenRepository，调用AUTHZ_USER_PROFILE表</p><h5 id="ms-customer-authorization-4.4OSPLTokenServiceImpl"><span style="color: rgb(0,0,0);"><strong>4.4 OSPL</strong><strong>TokenServiceImpl</strong></span></h5><p>用到1张表：AuthorizerTokenRepository，调用AUTHZ_USER_PROFILE表</p><p><br/></p><h4 id="ms-customer-authorization-5.接口AuthorizationStrategy">5. 接口AuthorizationStrategy</h4><p>该接口提供了2个方法（核心功能）：triggerAuthorization()和validateAuthorization()。</p><p>该接口有4个实现类：SMSAuthorizationServiceImpl，EmailAuthorizationServiceImpl，SoftTokenAuthorizationServiceImpl，HardTokenAuthorizationServiceImpl。</p><p>而且，每个实现类都关联了一个接口，比如SMSAuthorizationServiceImpl关联了<strong>SMSService</strong>接口。</p><p><br/></p><p><strong>通过AuthorizationStrategy接口实现了token type维度的扩展。</strong></p><p><strong>不论哪种token，都需要有请求（发送）和校验的核心功能。</strong></p><p><br/></p><p><strong>通过XXXService接口，又实现了channel维度的扩展。</strong></p><p><strong>因为任何一种token，对应到不同的channel，请求（发送）和校验的功能的具体实现又存在不同。</strong></p><p><strong>通过这种设计，实现了2个维度的扩展。</strong></p><p><span style="color: rgb(255,0,0);">问题：在SMSAuthorizationServiceImpl类的triggerAuthorization()方法具体逻辑，和INBSmsTokenServiceImpl类的requestSMSOTP()方法的具体逻辑，有什么不同？</span></p><p><span style="color: rgb(255,0,0);"><span style="color: rgb(0,51,102);">SMSAuthorizationServiceImpl类的triggerAuthorization()方法的功能简单，主要是根据channel设置AuthorizationContext的identity字段，决定SMSService接口的具体实现类，比如<span style="color: rgb(255,0,0);">INBSmsTokenServiceImpl类。</span></span></span></p><p><span style="color: rgb(255,0,0);"><span style="color: rgb(0,51,102);">在INBSmsTokenServiceImpl类的requestSMSOTP()方法，实现具体逻辑。</span></span></p><p><span style="color: rgb(255,0,0);">=========TBC</span></p><h5 id="ms-customer-authorization-5.1.接口SMSService"><span style="color: rgb(0,0,0);">5.1. 接口SMSService</span></h5><p>该接口提供了2个方法：requestSMSOTP()，validateSMSOTP()。</p><p>该接口有多个实现类：<strong>INBSmsTokenServiceImpl</strong>，BVSmsTokenServiceImpl，MBSSSmsTokenServiceImpl，DefaultSmsTokenServiceImpl。</p><p><span style="color: rgb(255,0,0);">INBSmsTokenServiceImpl这个类复杂吗？</span></p><h5 id="ms-customer-authorization-5.2.接口SoftTokenService"><span style="color: rgb(0,0,0);">5.2. 接口SoftTokenService</span></h5><p>该接口提供了3个方法：handleRequest()，handleValidate()，checkIfActive()</p><p>该接口有多个实现类：INBSoftTokenServiceImpl，BVSoftTokenServiceImpl，MBSSSoftTokenServiceImpl，DefaultSoftTokenServiceImpl。</p><h5 id="ms-customer-authorization-5.3.接口HardTokenService"><span style="color: rgb(0,0,0);">5.3. 接口HardTokenService</span></h5><p>该接口提供了2个方法：hardTokenRequest()，hardTokenValidate()</p><p>该接口有多个实现类：INBHardTokenServiceImpl，BVHardTokenServiceImpl，MBSSHardTokenServiceImpl，DefaultHardTokenServiceImpl。</p><h4 id="ms-customer-authorization-6.TriggerServiceImpl">6. TriggerServiceImpl</h4><p>主要完成request核心功能之前的准备工作，并调用<strong>AuthorizationStrategy</strong>的具体实现类实现核心功能。</p><h5 id="ms-customer-authorization-1.preHandle()"><span style="color: rgb(0,0,0);">1. preHandle()</span></h5><p>判断是否是passthrough。</p><h5 id="ms-customer-authorization-2.triggerAuthorization()"><span style="color: rgb(0,0,0);">2. triggerAuthorization()</span></h5><p>具体执行trigger服务。实际上是由<strong>AuthorizationStrategy</strong>的具体实现类（SMSAuthorizationServiceImpl，EmailAuthorizationServiceImpl，SoftTokenAuthorizationServiceImpl，HardTokenAuthorizationServiceImpl）的<strong>triggerAuthorization()</strong>方法实现。</p><p>而<strong>triggerAuthorization()</strong>方法调用了<strong>SMSService</strong>接口的具体实现类，比如<strong>INBSMSServiceImpl</strong>类的<strong>requestSMSOTP()</strong>方法。</p><p>而<strong>requestSMSOTP()</strong>方法调用了<strong>NotificationService</strong>接口的具体实现类，比如<strong>CustomerNotificationServiceImpl</strong>类的<strong>send</strong>()方法。</p><p>而<strong>send</strong>()方法的具体实现包括以下子方法：</p><p>prepareDataAndDoSend()</p><p>preparePayloadParam()</p><p>addAdditionalParam()</p><p>prepareNotificationData()</p><p>最终调用sdk提供的<strong>clientNotificationSdkProcessor</strong>类的<strong>processNotification</strong>()方法发送消息。</p><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="attachments/6389763/6389798.png" data-image-src="http://confluence.txw.com:9090/download/attachments/6389763/image2023-9-26_23-18-37.png?version=1&amp;modificationDate=1695741517000&amp;api=v2"></span></p><h5 id="ms-customer-authorization-3.triggerAuthzService()"><span style="color: rgb(0,0,0);">3. triggerAuthzService()</span></h5><p>处理发送消息给用户，包括SMS，EMAIL，SWK。实际调用抽象父类<strong>AbstractTrigger</strong>的triggerAuthorization()。</p><h5 id="ms-customer-authorization-4.handle()"><span style="color: rgb(0,0,0);">4. handle()</span></h5><p>调用triggerAuthzService()方法。</p><h5 id="ms-customer-authorization-5.checkForAuthTypeChannel()"><span style="color: rgb(0,0,0);">5. checkForAuthTypeChannel()</span></h5><p>比较authorization type，选择最优先。</p><p><br/></p><h4 id="ms-customer-authorization-响应">响应</h4><div class="table-wrap"><table class="fixed-table confluenceTable"><colgroup><col style="width: 188.0px;"/><col style="width: 327.0px;"/><col style="width: 641.0px;"/><col style="width: 125.0px;"/></colgroup><tbody><tr><th class="confluenceTh">字段</th><th class="confluenceTh">值 - ACCESS_ELEVATION</th><th colspan="1" class="confluenceTh"><span>值 - TAC</span></th><th colspan="1" class="confluenceTh">值 - GENERIC</th></tr><tr><td class="confluenceTd">triggerOTP</td><td class="confluenceTd">authContext.triggerOTP</td><td colspan="1" class="confluenceTd">同</td><td colspan="1" class="confluenceTd"><span>同</span></td></tr><tr><td class="confluenceTd">requireChallengeCode</td><td class="confluenceTd">authContext.requireChallengeCode</td><td colspan="1" class="confluenceTd">同</td><td colspan="1" class="confluenceTd"><span>同</span></td></tr><tr><td colspan="1" class="confluenceTd">authId</td><td colspan="1" class="confluenceTd">updateAuthTxnEntity.Id</td><td colspan="1" class="confluenceTd">同</td><td colspan="1" class="confluenceTd"><span>同</span></td></tr><tr><td colspan="1" class="confluenceTd">txnId</td><td colspan="1" class="confluenceTd">updateAuthTxnEntity.txnId</td><td colspan="1" class="confluenceTd">同</td><td colspan="1" class="confluenceTd"><span>同</span></td></tr><tr><td class="confluenceTd">status</td><td class="confluenceTd">ELEVATION_REQUIRED</td><td colspan="1" class="confluenceTd"><span>TAC_REQUIRED</span></td><td colspan="1" class="confluenceTd">NA</td></tr><tr><td class="confluenceTd">authReference</td><td class="confluenceTd"><span>updateAuthTxnEntity</span>.authReference</td><td colspan="1" class="confluenceTd">同</td><td colspan="1" class="confluenceTd"><span>同</span></td></tr><tr><td class="confluenceTd"><span style="color: rgb(0,0,0);"><strong>challengeCode</strong></span></td><td class="confluenceTd"><span><span>updateAuthTxnEntity</span>.challengeCode</span></td><td colspan="1" class="confluenceTd"><p><span style="color: rgb(0,0,0);">TxnUtil.identifyOOBChallengeCode(authContext.channel, updateAuthTxnEntity)</span></p><p><strong><span style="color: rgb(0,0,0);">如果是BV而且是firstTimeTxn，返回null，因为challengeCode会通过Email发送给用户。</span></strong></p><p><strong><span style="color: rgb(0,0,0);">否则返回updateAuthTxnEntity.challengeCode。</span></strong></p></td><td colspan="1" class="confluenceTd"><span>NA</span></td></tr><tr><td class="confluenceTd">notifySoftToken</td><td class="confluenceTd">triggerAuthResult.notifySoftToken</td><td colspan="1" class="confluenceTd">同</td><td colspan="1" class="confluenceTd"><span>NA</span></td></tr><tr><td class="confluenceTd">authTypeCode</td><td class="confluenceTd">updateAuthTxnEntity.authPolicy.authType</td><td colspan="1" class="confluenceTd">同</td><td colspan="1" class="confluenceTd"><span>同</span></td></tr><tr><td class="confluenceTd"><p><strong>最终授权类型</strong></p><p><strong>availableAuthTypeCode</strong></p></td><td class="confluenceTd">authTxnEntity.<span>availableAuthTypeCode</span></td><td colspan="1" class="confluenceTd">同</td><td colspan="1" class="confluenceTd"><span>NA</span></td></tr><tr><td colspan="1" class="confluenceTd">maskedMobileNo</td><td colspan="1" class="confluenceTd"><span>updateAuthTxnEntity.maskedMobileNo</span></td><td colspan="1" class="confluenceTd">同</td><td colspan="1" class="confluenceTd"><span>NA</span></td></tr><tr><td colspan="1" class="confluenceTd">maskedEmailAddress</td><td colspan="1" class="confluenceTd"><span>updateAuthTxnEntity.maskedEmailAddress</span></td><td colspan="1" class="confluenceTd">同</td><td colspan="1" class="confluenceTd"><span>NA</span></td></tr><tr><td colspan="1" class="confluenceTd">tokens</td><td colspan="1" class="confluenceTd">tokens</td><td colspan="1" class="confluenceTd">同</td><td colspan="1" class="confluenceTd"><span>NA</span></td></tr><tr><td colspan="1" class="confluenceTd">isSWKFirstLogin</td><td colspan="1" class="confluenceTd">authContext.isSwkFirstLogin</td><td colspan="1" class="confluenceTd">NA</td><td colspan="1" class="confluenceTd"><span>NA</span></td></tr><tr><td colspan="1" class="confluenceTd"><span>isSWKFirstTxn</span></td><td colspan="1" class="confluenceTd">NA</td><td colspan="1" class="confluenceTd"><p>if(includeSWKFirstTxnChannels=empty || not includeSWKFirstTxnChannels.contains(channel)) {<br/>isSWKFirstTxn = authTxnEntity.authPolicy.authType is SWK &amp;&amp; authContext.isSwkFirstTxn;<br/>}<br/>includeSWKFirstTxnChannels = MBSS, MBSS_MO</p><p>// 如果channel是MBSS, MBSS_MO，按照<strong>authContext.isSwkFirstTxn</strong>返回。</p><p>// 否则，按照<strong>authTxnEntity.authPolicy.authType is SWK &amp;&amp; authContext.isSwkFirstTxn</strong>返回。</p></td><td colspan="1" class="confluenceTd"><span>NA</span></td></tr><tr><td colspan="1" class="confluenceTd">sendSuccess</td><td colspan="1" class="confluenceTd">authContext.pushNotificationStatus</td><td colspan="1" class="confluenceTd">同</td><td colspan="1" class="confluenceTd"><span>同</span></td></tr><tr><td colspan="1" class="confluenceTd">oAuthDetails</td><td colspan="1" class="confluenceTd"><p>authContext.requestHeader.accOp</p><p><span>authContext.requestHeader.refOp</span></p></td><td colspan="1" class="confluenceTd">NA</td><td colspan="1" class="confluenceTd"><span>NA</span></td></tr><tr><td colspan="1" class="confluenceTd">userRemainingCount</td><td colspan="1" class="confluenceTd">authContext.userRemainingCount</td><td colspan="1" class="confluenceTd">同</td><td colspan="1" class="confluenceTd"><span>NA</span></td></tr><tr><td colspan="1" class="confluenceTd">auditLogDTO</td><td colspan="1" class="confluenceTd">NA</td><td colspan="1" class="confluenceTd">authContext.auditLogDTO</td><td colspan="1" class="confluenceTd"><span>NA</span></td></tr></tbody></table></div><p>注：<span>tokens字段</span></p><p>boolean includeTokenSerialNo = isTsnNotifySoftToken ? triggerAuthResult.notifySoftToken == NO_SENDING : authContext.shadowDeviceModeFlag=YES;</p><p>List&lt;TokensResponse&gt; tokens = includeTokenSerialNo &amp;&amp; authContext.finalAuthType=SWK ? updatedAuthTxnEntity.tokenSerialNo : null;</p><p>// 如果isTsnNotifySoftToken = true，是否返回tokenSerialNo由notifySoftToken决定，如果没发送消息NO_SENDING，则可能返回tokens，否则如果已经发送消息，则不返回tokens。</p><p>// 如果是false，表示由shadowDeviceMode决定。如果是shadowDevice，则返回tokens，否则不返回。</p><p>// sg，my，cn，hk是true</p><p>// corpsg，corpmy是false</p><p>// 如果<strong>最终的授权类型FinalAuthType是SWK</strong>，而且<strong>没有发送应用消息</strong>或者是<strong>shadow device</strong>，则返回tokenSerialNo。</p><p> </p><p><br/></p><h3 id="ms-customer-authorization-API/tac/validate"><strong>API /tac/validate</strong></h3><p><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image confluence-external-resource" src="attachments/6389763/6389802.png" data-image-src="http://confluence.txw.com:9090/download/attachments/6389763/image2023-9-26_23-29-40.png?version=1&amp;modificationDate=1695742180000&amp;api=v2"></span></p><h4 id="ms-customer-authorization-1.TACValidateServiceImpl">1. TACValidateServiceImpl</h4><p>主要方法handle()，包括3个步骤。</p><h5 id="ms-customer-authorization-step1，查询AUTHZ_TXN表。"><span style="color: rgb(0,0,0);"><strong>step1</strong>，查询<strong>AUTHZ_TXN</strong>表。</span></h5><p><span style="color: rgb(0,0,0);">校验txnId是否一致。</span></p><h5 id="ms-customer-authorization-step2，根据AUTHZ_REF_CHECK配置和authz_policy表"><span style="color: rgb(0,0,0);"><strong>step2</strong>，根据AUTHZ_REF_CHECK配置和<strong>authz_policy</strong>表</span></h5><p><span style="color: rgb(0,0,0);">校验随机码authReference。</span></p><h5 id="ms-customer-authorization-step3，使用TxnUtl类checkDurationFlow()"><span style="color: rgb(0,0,0);"><strong>step3</strong>，使用<strong>TxnUtl</strong>类checkDurationFlow()</span></h5><p><br/></p><p><span style="color: rgb(0,0,0);">在校验之前检查authz_status。</span></p><p><span style="color: rgb(0,0,0);">通过<strong>MessageServieImpl</strong>类的validatePreConditionsAndThrow()，进行预校验。</span></p><h5 id="ms-customer-authorization-step4，使用了AuthorizationStrategy及其具体实现类"><span style="color: rgb(0,0,0);"><strong>step4</strong>，使用了<strong>AuthorizationStrategy</strong>及其具体实现类</span></h5><p>调用<strong>validateAuthorization</strong>()方法进行校验。</p><p>如果是Email，Standalone。</p><p>如果是HardToken，</p><div class="table-wrap"><table class="fixed-table confluenceTable"><colgroup><col style="width: 74.0px;"/><col style="width: 328.0px;"/></colgroup><tbody><tr><th class="confluenceTh">Channel</th><th class="confluenceTh">校验</th></tr><tr><td class="confluenceTd">BV</td><td class="confluenceTd">Invoke SSO verifyHWKTAC/verifyHWKOTP</td></tr><tr><td class="confluenceTd">INB</td><td class="confluenceTd"><span>Invoke ms-token-mgn<span>/tfa/otp/verify</span></span></td></tr><tr><td class="confluenceTd">MBSS</td><td class="confluenceTd">Invoke ms-token-mgn<span>/tfa/otp/verify</span></td></tr></tbody></table></div><p>如果是SMS，</p><div class="table-wrap"><table class="relative-table confluenceTable" style="width: 27.9135%;"><colgroup><col style="width: 18.5526%;"/><col style="width: 81.4818%;"/></colgroup><tbody><tr><th class="confluenceTh">Channel</th><th class="confluenceTh">校验</th></tr><tr><td class="confluenceTd"><span>BV</span></td><td class="confluenceTd"><span>Invoke SSO 2FA-VerifyOTP-I</span></td></tr><tr><td class="confluenceTd">INB</td><td class="confluenceTd"><span>Invoke ms-token-mgn/tfa/otp/verify</span></td></tr><tr><td class="confluenceTd">MBSS</td><td class="confluenceTd"><span>Invoke ms-token-mgn<span>/tfa/otp/verify</span></span></td></tr></tbody></table></div><p>如果是SoftToken，</p><div class="table-wrap"><table class="relative-table confluenceTable" style="width: 30.1465%;"><colgroup><col style="width: 17.1723%;"/><col style="width: 82.8596%;"/></colgroup><tbody><tr><th class="confluenceTh">Channel</th><th class="confluenceTh">校验</th></tr><tr><td class="confluenceTd"><span>BV</span></td><td class="confluenceTd"><span>Invoke SSO verifySoftTokenTAC/verifySoftTokenOTP</span></td></tr><tr><td class="confluenceTd"><span>INB</span></td><td class="confluenceTd">Invoke SOA UAS-VerifyOTP</td></tr><tr><td class="confluenceTd"><span>MBSS</span></td><td class="confluenceTd"><span>Invoke ms-token-mgn/soft-tokens/otp/validate</span></td></tr></tbody></table></div><p><br/></p><p>比如BVSoftTokenServiceImpl具体实现类的handleValidate()方法，调用SSOServiceFacade的verifyOTPByMFAType()，调用SSOSWKService类的verifyTAC()，调用SSOIntegrationClient类的verifySoftTokenTAC()进行校验。</p><p>实际上，SSOIntegrationClient类实现了各种校验，包括SSOSWKService，SSOHWKService，SSOSMSService。</p><p>注：SoftToken、HardToken、SMS都需要先调用tokenService.queryUserProfile()。</p><h5 id="ms-customer-authorization-step5，根据校验结果，更新AUTHZ_TXN表。"><span style="color: rgb(0,0,0);"><strong>step5</strong>，根据校验结果，更新<strong>AUTHZ_TXN</strong>表。</span></h5><p>如果校验成功，更新authTxn.authStatus=VERIFIED。<strong>检查是否需要触发multi step流程。</strong></p><p>如果校验失败，更新authTxn.authCount+1。</p><p><br/></p><h4 id="ms-customer-authorization-2.MessageServiceImpl">2. MessageServiceImpl</h4><p>提供了validatePreConditionsAndThrow()方法，在调用validate核心功能之前，检查状态和校验。</p><h3 id="ms-customer-authorization-API/otp/request"><strong>API /otp/request</strong></h3><p><span style="color: rgb(255,0,0);">这个API，对于不同的channel有区别吗？<span style="color: rgb(0,51,102);">基本没有。</span></span></p><p>通过<strong>GenericElevationServiceImpl</strong>类的<strong>genericOTPAndSendSMSorNotification()</strong>创建OTP，并发送（SMS，Email）。</p><h4 id="ms-customer-authorization-step1，通过请求头request.mobileNo是否为空，判断是通过SMS还是Email发送OTP。">step1，通过请求头request.mobileNo是否为空，判断是通过SMS还是Email发送OTP。</h4><h4 id="ms-customer-authorization-step2，通过MessageServiceImpl类isEligibleForTriggering()，判断当前的AUTHZ_STS_CD状态字段，是否有资格/允许发送OTP。">step2，通过<strong>MessageServiceImpl</strong>类<strong>isEligibleForTriggering</strong>()，判断当前的AUTHZ_STS_CD状态字段，是否有资格/允许发送OTP。</h4><h4 id="ms-customer-authorization-step3，通过GenericUtility类generateOTP()，产生OTP，并计算hash值。产生参考码AuthReference，是否有条件？">step3，通过<strong>GenericUtility</strong>类<strong>generateOTP</strong>()，产生OTP，并计算hash值。<span style="color: rgb(255,0,0);">产生参考码</span>AuthReference，是否有条件？</h4><h4 id="ms-customer-authorization-step4，通过AuthorizationPolicyCache类从本地缓存或者AUTHZ_POLICY表查询配置，设置OTP的有效时长。">step4，通过<strong>AuthorizationPolicyCache</strong>类从本地缓存或者<strong>AUTHZ_POLICY</strong>表查询配置，设置OTP的有效时长。</h4><h4 id="ms-customer-authorization-step5，更新AUTHZ_TXN表。">step5，更新<strong>AUTHZ_TXN</strong>表。</h4><h4 id="ms-customer-authorization-step6，通过NotificationService类send()方法，发送消息。实际通过ms-customer-notification-sdk。">step6，通过<strong>NotificationService</strong>类<strong>send</strong>()方法，发送消息。实际通过<strong>ms-customer-notification-sdk</strong>。</h4><p><br/></p><h3 id="ms-customer-authorization-API/otp/validate"><strong>API /otp/validate</strong></h3><p>通过<strong>GenericElevationServiceImpl</strong>类的<strong>genericOTPValidateV2</strong>()校验OTP。</p><h4 id="ms-customer-authorization-step1，通过请求头的authID，查询AUTHZ_TXN表。">step1，通过请求头的auth ID，查询<strong style="letter-spacing: 0.0px;">AUTHZ_TXN</strong>表。</h4><h4 id="ms-customer-authorization-step2，预校验。校验请求头字段和表记录是否一致，包括transactionID，参考码。">step2，预校验。校验请求头字段和表记录是否一致，包括transactionID，参考码。</h4><h4 id="ms-customer-authorization-step3，通过比较请求头的otp和表记录的otp，进行hash校验。">step3，通过比较请求头的otp和表记录的otp，进行hash校验。</h4><h4 id="ms-customer-authorization-step4，根据校验结果，更新AUTHZ_TXN表。">step4，根据校验结果，更新<strong>AUTHZ_TXN</strong>表。</h4><h3 id="ms-customer-authorization-API/otp/daily-limit-check"><strong>API /otp/daily-limit-check</strong></h3><p>通过<strong>GenericElevationServiceImpl</strong>类的<strong>getDailyLimitStatus</strong>()方法。</p><p>该方法查询AUTHZ_TXN表，通过channel + transaction Id。</p><p>返回结果NEW OTP，LIMIT EXCEED，WITHIN DAILY LIMIT。</p><h3 id="ms-customer-authorization-API/v3/access-elevation/request"><strong>API /v3/access-elevation/request</strong></h3><h4 id="ms-customer-authorization-1.AccessElevationRequestServiceImpl">1. AccessElevationRequestServiceImpl</h4><p>主要方法<strong>handle</strong>()，包括?个步骤。</p><h5 id="ms-customer-authorization-预处理">预处理</h5><p>判断是否passthrough。</p><p>通过<strong>AccessElevationCache</strong>类从本地缓存或者<strong>ACCESS_ELEVATION</strong>表查询相关配置。</p><p>校验jwtDomain</p><p>校验是否需要提权，比较表字段ial和请求头amr字段。</p><h5 id="ms-customer-authorization-Step1，获取用户的可用token列表">Step1，获取用户的可用token列表</h5><p>通过TokenService具体实现类的queryUserProfile()，查询缓存或SOA。</p><h5 id="ms-customer-authorization-Step2：decideAuthorizationType判断（用户可选的）授权类型">Step2：decideAuthorizationType <strong>判断（用户可选的）授权类型</strong></h5><p>使用了<strong>TokenService</strong>及其具体实现类的decideAuthorizationType()。</p><p>通过<strong>AuthorizationPolicyCache</strong>类从本地缓存或者<strong>AUTHZ_POLICY</strong>表查询配置</p><h5 id="ms-customer-authorization-Step3：updateAndTrigger请求授权和发送消息">Step3：updateAndTrigger <strong>请求授权和发送消息</strong></h5><p>如果triggerOTP为Y，通过TriggerServiceImpl类的triggerAuthzService()，实际上通过AuthorizationStrategy的具体实现类的triggerAuthorization()实现。</p><p><br/></p><h3 id="ms-customer-authorization-API/v3/access-elevation/validate"><strong>API /v3/access-elevation/validate</strong></h3><h4 id="ms-customer-authorization-1.AccessElevationValidateServiceImpl">1. AccessElevationValidateServiceImpl</h4><h5 id="ms-customer-authorization-step1，通过请求头的authID，查询AUTHZ_TXN表。.1">step1，通过请求头的auth ID，查询<strong>AUTHZ_TXN</strong>表。</h5><h5 id="ms-customer-authorization-step2，预校验。校验当前状态。">step2，预校验。校验当前状态。</h5><p>通过<strong>MessageServieImpl</strong>类的validatePreConditionsAndThrow，进行预校验。</p><h5 id="ms-customer-authorization-step3，使用了AuthorizationStrategy及其具体实现类validateAuthorization()">step3，使用了<strong>AuthorizationStrategy</strong>及其具体实现类validateAuthorization()</h5><h5 id="ms-customer-authorization-step4，校验后处理">step4，校验后处理</h5><p>如果校验成功，更新<strong>AUTHZ_TXN</strong>表状态字段，并发送kafka消息。</p><p>如果校验失败，更新<strong>AUTHZ_TXN</strong>表失败次数字段，并抛出异常。</p><h3 id="ms-customer-authorization-API/internal/access-elevation/shadow/validate">API /internal/access-elevation/shadow/validate</h3><p><strong>步骤</strong>：</p><p>1. 通过channel和fn=ELEVATION查询access-elevation。</p><p>2. 通过channel和AuthType=SWK，查询auth_policy。</p><p>3. 如果request.otpValidationResult=SUCCESS，skip UAS otp validation invoke，并返回。</p><p>4. 如果不是shadowValidate，则需要调用tokenService.queryUserProfile()。</p><p>5. 复用调用softTokenService.handleValidate()。</p><p>Mobile - Post login <br/>A1. Cust sec will call GET /mfa/token/preference to cust authz to check what token user have <br/>A2. If user swk in cooling period of past cooling period but oob not done, cust sec will return indicator to mobile saying swk not ready, go to A3.1 otherwise go with A3.2</p><p>A3.1. If swk not ready, Mobile will repeat B1 and B2 for sms otp</p><p>A3.2. If swk is ready, cust sec will call internal/shadow-elevatiom/validate api to complete swk otp flow</p><p>mfe post login <br/>B1. Mfe calls POST /access-elevation/request<br/>B2. Mfe or mobile calls POST /access-elevation/validate</p><p><br/></p><p><strong>Mobile - Post login</strong></p><p>A1. cust-sec → cust-auth/mfa/token/preference GET,</p><p>返回List&lt;String&gt; <strong>availableOptions</strong>（比如[SWK, HWK, SMS_OTP]），</p><p>List&lt;ActivatedToken&gt; <strong>activatedOptions</strong>（isCoolingPeriod, afterCoolingPeriodToVerifiedOtp, coolingPeriodRemaining, tokenStepUpRequest, tokenStepUpExpiry, deviceInfo, coolingPeriodIndicator）</p><p>如果用户的SWK在cooling period，但是OOB没有完成，返回mobile：SWK not ready，走A2.1。否则走A2.2</p><p>A2.1 如果SWK not ready，重复B1和B2，sms otp。</p><p>A2.2 如果SWK is ready，cust-sec → cust-auth/internal/shadow/validate, 完成SWK OTP flow。</p><p>otpValidationResult=SUCCESS, no validate anymore。</p><p><br/></p><p><strong>MFE - Post Login</strong></p><p>B1. MFE → POST /access-elevation/request</p><p>B2. MFE or Mobile -&gt; POST /access-elevation/validate</p><p><br/></p><p>cust-sec → iSprint validate SWK</p><p><strong>after cooling period, if first time txn</strong></p><p>cust-sec → cust-auth/2fa/request</p><p><br/></p><p>mb → cust-auth/2fa/validate </p><p><strong>if not first time txn, means oob is done</strong></p><p><strong>if swk available, and oob is done</strong></p><p>cust-sec → cust-auth/shadow/validate, otpValidationResult=SUCCESS, no validate anymore</p><p><br/></p><h3 id="ms-customer-authorization-AuthenticationContext上下文类"><strong>AuthenticationContext 上下文类</strong></h3><p>accessElevationRequest<br/>请求体中access-elevation/request</p><p>accessElevationValidate<br/>请求体中access-elevation/validate</p><p>authorizationElevationRequest</p><p><strong>authorizerTokenEntity</strong><br/>存储用户信息user profile，对应AUTHZ_USER_PROFILE表</p><p>challengeCode<br/>产生的ChallengeCode，或者请求的传参。<br/>customerChallengeCode<br/>请求传参是否包含challengeCode。</p><p>mfaType</p><p>tacRequest<br/>请求体</p><p>tacValidate<br/>请求体</p><p><br/></p><p>triggerOTP<br/>是否触发OTP</p><p>transactionPayload<br/>请求体</p><h3 id="ms-customer-authorization-CommonContext"><strong>CommonContext</strong></h3><p>auditModel<br/>channel<br/>headers<br/>tokenContext<br/>存储token信息，来源于jwt</p><p>tokenContext.custom</p><h3 id="ms-customer-authorization-API/mfa/login-mode"><strong>API /mfa/login-mode</strong></h3><p>暂未实现。</p><h3 id="ms-customer-authorization-API/mfa/otp"><strong>API /mfa/otp</strong></h3><p>实际上通过<strong>TriggerServiceImpl</strong>类<strong>handle</strong>()方法，其余参考/tac/request。</p><h3 id="ms-customer-authorization-APIGET/mfa/token/preference"><strong>API GET /mfa/token/preference</strong></h3><p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image confluence-external-resource" height="250" src="attachments/6389763/6750221.png" data-image-src="http://confluence.txw.com:9090/download/attachments/6389763/image2023-10-5_11-45-26.png?version=1&amp;modificationDate=1696477527000&amp;api=v2"></span></p><p>通过<strong>ITokenPreferenceService</strong>的具体实现类<strong>query</strong>()方法，</p><p>以下以INBTokenPreferenceServiceImpl为例。</p><p>AUTHZ_USER_PROFILE</p><p>1. 通过<strong>TokenService</strong>的具体实现类的<strong>queryUserProfile</strong>()方法，查询缓存或SOA，获取user profile，并设置isSwkSvcDown字段。</p><p>在co-existence模式下，通过<strong>INB USP</strong>同步数据，获取INB token preference，并入库<strong>cust_token_preference</strong>表。</p><p><strong>返回体包括：displayPreference，defaultSelection，availableOptions，activatedOptions，userProfiles，isSwkSvcDown等字段。</strong></p><p>在非co-existence模式下，不需要通过INB USP同步数据，通过查询本地cust_token_preference表处理。</p><p>2. 获取并设置activatedOptions列表字段。</p><p>根据availableOptions列表和status字段，获取activatedOptions列表，包括tokenType，swkStatus，status，swkStepUpEligibility，mobileNo字段。</p><p>如果是SWK，设置isCoolingPeriod，deviceInfo（包括tsn，tid，fpt），tokenStepUpRequestDate，tokenStepUpExpiryDate字段。</p><p>如果是HWK，设置deviceInfo（包括tsn）。</p><h3 id="ms-customer-authorization-APIGET/tac/limits"><strong>API GET /tac/limits</strong></h3><p>如果请求参数不包括transaction type list，通过<strong>TACServiceImpl</strong>类，同步调用SOA的EBS-TransSigningLimit-I接口，获取结果列表，包括每个transaction type对应的limit。</p><p>如果请求参数包括，</p><p>获取EBS的配置项。</p><p>通过<strong>TACServiceImpl</strong>类，异步调用SOA的EBS-TransSigningLimit-I接口。</p><p>通过<strong>TACServiceImpl</strong>类，查询数据库TAC表，channel为INB。</p><p>最后把得到的transaction type list合并。</p><h3 id="ms-customer-authorization-API/tac/authorization-status/retrieve"><strong>API /tac/authorization-status/retrieve</strong></h3><p>通过请求头判断channel。</p><p>通过<strong>TACServiceImpl</strong>类status()方法，判断是否passthrough模式，查询AUTHZ_TXN表。</p><p>校验记录是否过期。</p><p>校验是否多步骤交易签名。返回SUCCESS（所有记录状态都是VERIFIED），FAILED（任何一步是BLOCKED），PENDING（其他情况）。</p><p><br/></p><h2 id="ms-customer-authorization-主要业务流程">主要业务流程</h2><h2 id="ms-customer-authorization-主要架构设计方案">主要架构设计方案</h2><h2 id="ms-customer-authorization-主要数据库设计">主要数据库设计</h2><h2 id="ms-customer-authorization-遇到的问题和解决方案">遇到的问题和解决方案</h2><h2 id="ms-customer-authorization-优缺点和改进方案分析，业界对比">优缺点和改进方案分析，业界对比</h2><p><br/></p>
                    </div>

                                        <div class="pageSection group">
                        <div class="pageSectionHeader">
                            <h2 id="attachments" class="pageSectionTitle">Attachments:</h2>
                        </div>

                        <div class="greybox" align="left">
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/6389763/6389764.png">image2023-9-19_22-40-38.png</a> (image/png)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/6389763/6389794.png">image2023-9-24_23-25-11.png</a> (image/png)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/6389763/6389798.png">image2023-9-26_23-18-37.png</a> (image/png)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/6389763/6389801.png">image2023-9-26_23-25-24.png</a> (image/png)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/6389763/6389802.png">image2023-9-26_23-29-40.png</a> (image/png)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/6389763/6389805.pdf">ms-customer-authorization2.pdf</a> (application/pdf)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/6389763/6750221.png">image2023-10-5_11-45-26.png</a> (image/png)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/6389763/7176198.jpeg">IMG_0302.jpeg</a> (image/jpeg)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/6389763/7176199.jpeg">IMG_0301.jpeg</a> (image/jpeg)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/6389763/7176200.jpeg">IMG_0300.jpeg</a> (image/jpeg)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/6389763/7176201.jpeg">IMG_0299.jpeg</a> (image/jpeg)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/6389763/7176202.jpeg">IMG_0298.jpeg</a> (image/jpeg)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/6389763/7176203.jpeg">IMG_0297.jpeg</a> (image/jpeg)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/6389763/7176204.jpeg">IMG_0296.jpeg</a> (image/jpeg)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/6389763/7176205.jpeg">IMG_0295.jpeg</a> (image/jpeg)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/6389763/7176206.jpeg">IMG_0294.jpeg</a> (image/jpeg)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/6389763/7176207.jpeg">IMG_0293.jpeg</a> (image/jpeg)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/6389763/7176223.jpeg">IMG_0304.jpeg</a> (image/jpeg)
                                <br/>
                                                            <img src="images/icons/bullet_blue.gif" height="8" width="8" alt=""/>
                                <a href="attachments/6389763/7176224.jpeg">IMG_0303.jpeg</a> (image/jpeg)
                                <br/>
                                                    </div>
                    </div>
                    
                                                      
                </div>             </div> 
            <div id="footer" role="contentinfo">
                <section class="footer-body">
                    <p>Document generated by Confluence on 六月 14, 2025 21:40</p>
                    <div id="footer-logo"><a href="http://www.atlassian.com/">Atlassian</a></div>
                </section>
            </div>
        </div>     </body>
</html>
